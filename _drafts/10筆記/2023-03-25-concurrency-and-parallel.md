
# Concurrency vs Parallel
Python在3.5版本中開始支援使用協程(coroutines)來撰寫非同步(asynchronous)程式，並使用 async 和 await 語法來實現。coroutines 是由兩個單字合併而成的，分別是 cooperation + routine， cooperation 意指合作，routine 意指例行事件。這裡 routine 指得是程序中被呼叫的 function。將 function 協同其他更多的 function 共同作業這件事情稱為 coroutines。

> 在3.5版本之前通常都使用yield，但是此用法在3.8已經被棄用

Python 提供的協程機制可以讓你在等待 I/O bound 操作時，讓其他的程式碼可以被執行。使用 async 和 await 語法可以讓你的程式在等待時不會被鎖住，而是可以去做其他的事情，當等待的操作完成後，程式再回到該處繼續執行。在本文中，我們將逐一的解釋以下內容：

- Coroutines
- Asynchronous Code
- async and await

## Coroutines
協程是 Python 中用於實現非同步程式碼的機制，透過它可以創建非同步函式。協程的特點是可以暫停和恢復執行，這使得程式碼可以在等待 I/O 操作完成時繼續執行其他任務，從而提高了程序的效率。以下圖事件舉例，就們在 main thread 執行到 function A 需等待 IO thread 結果，此時程序先暫停 function A 並協調讓出 main thread 使 main thread 去執行其他的事情(例如UI的選染)，等到 IO thread 耗時的處理結束後，再使 function A 繼續執行得到最終結果。以上例子就是典型的 Coroutines 概念。

![](https://miro.medium.com/v2/resize:fit:720/format:webp/1*mxsd2CH9qLnycFyHT0EQrQ.png)

## 非同步程式機制 (Asynchronous)
當程式碼需要等待某些事情完成時，可以讓電腦去執行其他任務。這種等待通常是指等待較慢的 I/O 運算，例如等待資料透過網路傳送、等待讀取磁碟檔案、等待資料庫操作完成等。由於等待這些操作所花費的時間佔了大部分執行時間，所以這種操作被稱為「I/O bound」操作。非同步系統的優點是，當一個任務完成時，它不需要立即把結果傳回，而是可以在稍等一下之後，再回來繼續執行。反之，同步系統需要等待上一個任務完成才能繼續執行下一個任務。接著要介紹兩個新名詞，並發(concurrency)和平行(parallelism) 都是指一次處理多個任務的能力，但是兩者之間有所不同。間單來說，Concurrency 強調的是多任務之間的交替執行，而 Parallel 強調的是多任務之間的真正同時處理。因此，Concurrency 更加注重系統的效率和執行效果，而 Parallel 更加注重處理速度和性能。

- Concurrency: 多件事可以在一段時間內同時進行
- Parallel: 有多件事可以在一個時間點同時進行

> 以下內容參考自[FastAPI](https://fastapi.tiangolo.com/async/)官方對於Async的說明，內文用很貼近生活的實例來說明，相當值得一讀。

### Concurrency
Concurrency 通常是指在同一個時間段內，有多個任務正在進行，但是這些任務之間可能是交替執行的，也可能是同時執行的，這取決於系統的調度和分配策略。Concurrency 的重點是讓多個任務交替進行，最終達到多任務並發的效果。例如，在瀏覽器中打開多個標籤頁時，這些標籤頁的載入和顯示是交替進行的，看起來好像是同時進行的。

為了解釋這個區別，FastAPI 官方文件舉了一個速食店買漢堡的例子。在這個例子中，你和你的暗戀對象去買漢堡。當你們排隊等待時，收銀員會先為前面的人點餐(處理其他程序)。當輪到你們時(觸發開始工作)，你向收銀員點了兩個漢堡。此時，收銀員會告訴廚師他們需要準備你們的漢堡，即使此時廚師還在準備之前客人的食物。你付錢後，收銀員會給你一個號碼。在等待漢堡的期間，你和你的同伴會去選桌子、聊天等等。此時，你的注意力不在收銀員那裡，而是在聊天上(等同於程式執行其他任務，如 UI 渲染)。但你也會時不時地檢查櫃台上的號碼，看是否輪到你了。當你們的漢堡準備好時，收銀員會在櫃台上顯示你們的號碼，你們便可以去拿漢堡並返回桌子吃。

![](https://i.imgur.com/zfRs7G6.png)

- 2個處理器（一個收銀員和一個廚師）

在這個例子中，你就像一台電腦/程式。當你在排隊時，你是閒置的，只是等待你的輪到。但當你和收銀員互動時，你會進行實際的工作，比如點餐、付款等等。當你等待漢堡時，你的工作暫停了，因為你必須等待漢堡製作完成。但當你坐在桌子旁時，你可以轉移注意力，去和你的同伴聊天，這樣你就又可以做一些有用的事情了。藉此不會為了等待而浪費時間。

### Parallel
Parallel 則是指同一個時間段內，有多個任務同時執行，每個任務都有一個獨立的執行緒或處理器核心進行處理。Parallel 的重點是實現真正的同時處理，從而加速任務的處理速度。例如，在電腦使用多個處理器核心同時執行多個任務，可以大大加速處理速度。

同樣以速食店為例，不同的是這間店有8個收銀員兼廚師同時接單和製作漢堡，但每次只能由一位工作人員處理一個訂單。因此每個人都必須等待前面的客人先取走他們的漢堡才能繼續下一個訂單。且因為沒有號碼牌等辨識訂單順序的方式，顧客必須自行留意並且確保不讓其他人取走他們的餐點。

![](https://i.imgur.com/1k3MSGN.png)

> 雖然這家店有8個處理器(收銀員兼廚師)，但是最終的體驗並不是最好的。

這樣的服務方式被稱為「同步」，因為所有人必須在同一時間等待烹煮完成。在這個情境下，你和你的同伴需要一直注意不讓其他人搶走他們的餐點，所以無法花太多時間聊天或互動(程式無法做其他事情)。整個過程需要同步地等待，就像是一台電腦/程式，必須無時無刻的等待在櫃檯前，這樣才能取得漢堡。但是在等待的過程中，你不能與你的同伴多認識彼此，因為你必須全神貫注地等待。此例子也顯示雖然並行操作可以提高效率，但如果同步操作不當，也可能導致效率降低和體驗不佳的情況。

以上例子說明，並發(concurrency)和平行(parallelism)的細節是不同的，前者指的是同時進行多個任務，而後者則指的是同時使用多個處理器來加速處理任務。

###  Concurrency vs Parallel 小結
這也是為什麼對於網路應用程式來說，使用非同步的程式設計方式非常重要。這種方式可以讓伺服器處理多個用戶請求，而不會因等待請求回應而浪費太多時間。因為很多客戶端會發請求給服務端，然後服務端響應給客戶端，如果有太多無用的等待，那麼整個應用將慢得無法使用。而且硬件資源有限，並發也能更高效利用資源，節約成本。

想當然這種非同步特性是 NodeJS 與 Go 程式語言受到歡迎的原因之一。而 FastAPI 的表現也跟 Go 相當，可以同時具備平行性和非同步性，比大多數被測試過的 NodeJS 框架表現更好。值得一提的是，Go 是一種接近 C 的編譯語言。

## Concurrency 一定就比 Parallel 好嗎？
並不全然，當只有在出現很多等待時(I/O bound)，Concurrency 才比 Parallel 好。假設我們要一間一間的打掃房間，由於大部分執行時間都被實際工作佔用而不是等待(CPU bound)，那麼 Concurrency 和 Parallel 就沒有區別。如果你再叫3個朋友一起打掃，Parallel 就能更快打掃完。這種執行時間完全取決於任務本身而不是等待的情況，又叫做CPU密集型(CPU bound)。電腦裡的CPU密集型操作通常需要更複雜的計算，例如：

- 音訊、圖片處理
- 電腦視覺
- 機器學習
- 深度學習

## Concurrency + Parallelism: Web + Machine Learning
FastAPI 是一個可以在 Web 開發中充分利用 concurrency（並發性）優勢的框架，就像 NodeJS 一樣。此外，它還可以利用 parallelism（平行性）和 multiprocessing（多處理）等特性，適用於像機器學習等需要 CPU 運算的工作負載。再加上 Python 是主要的資料科學、機器學習、深度學習的語言，因此 FastAPI 非常適合用於架設機器學習 API。

# 使用 FastAPI 實現高效能的 Python 非同步處理(下)
## async 和 await